/* ==================================
   main.js - Core functionality
   ⚠️ 이 파일은 manager.py가 자동 생성합니다
   ================================== */

// Detect OS for keyboard shortcuts
const isMac = navigator.platform.toUpperCase().indexOf('MAC') >= 0;
const isWin = navigator.platform.toUpperCase().indexOf('WIN') >= 0;

if (isMac) document.body.classList.add('is-mac');
else if (isWin) document.body.classList.add('is-win');

let currentLang = 'KR';
const sections = ['hero', 'journey', 'work', 'contact', 're', 'updates'];

// Data from manager.py
const journeyData = [{"year": "2025 - Present", "title_kr": "Independent Research", "title_en": "Independent Research", "desc_kr": "인공지능과 뇌과학의 교차점에서 새로운 가능성을 탐구하고 있습니다.", "desc_en": "Exploring new possibilities at the intersection of AI and neuroscience.", "tags": ["AI", "Neuroscience", "Research"]}, {"year": "2024", "title_kr": "The Beginning", "title_en": "The Beginning", "desc_kr": "AI의 세계에 첫 발을 내디뎠습니다. 끝없는 호기심이 여정의 시작이었습니다.", "desc_en": "Took my first steps into the world of AI. Endless curiosity marked the start of this journey.", "tags": ["Learning", "Exploration"]}];
const workData = [{"year": "2026", "title": "HND (Hypothesis-driven Negativet) Frame work", "desc_kr": "기존 유클리드 공식은 두 변수의 상호작용과 제약 조건($\\gcd(m,k)=1$)으로 인해 AI가 구조적 규칙을 찾기 어렵습니다. 본 연구는 슈티펠의 고전적 수열을 단일 변수 $n$으로 변환한 **Index Theory**를 사용하여, AI에게 가장 명확한 수론적 질서를 제시합니다.", "desc_en": "The existing Euclidean formula makes it difficult for AI to discover structural patterns due to the interaction between two variables and the constraint condition ($\\gcd(m,k)=1$). This study employs **exponential theory**, which transforms Stifel's classical sequence into a single variable $n$, to present the clearest possible arithmetic order to AI.", "tags": ["Paper"]}];

// Language content - Generated by manager.py
const content = {
    KR: {
        heroName: '전현준',
        heroSubtitle: 'AI & Neuroscience Explorer',
        bioText: '고개를 들어 세계를 보겠습니다. 세계라는 무대에서 만나뵙겠습니다.<br><br>저는 인공지능과 인류의 뇌를 공부하고 있는 전현준입니다.',
        journeyLabel: 'My Journey',
        workLabel: 'Work & Publications',
        contactLabel: 'Get in Touch',
        downloadCV: 'CV 다운로드',
        updatesLabel: 'Updates'
    },
    EN: {
        heroName: 'HYUNJUN Jeon',
        heroSubtitle: 'AI & Neuroscience Explorer',
        bioText: 'I will lift my head and look at the world. I will stand on the stage called the world.<br><br>I am Hyunjun Jeon, studying artificial intelligence and the human brain.',
        journeyLabel: 'My Journey',
        workLabel: 'Work & Publications',
        contactLabel: 'Get in Touch',
        downloadCV: 'Download CV',
        updatesLabel: 'Updates'
    }
};

function renderTimeline(data, containerId) {
    const container = document.getElementById(containerId);
    if (!container) return;
    
    container.innerHTML = data.map(item => `
        <div class="timeline-item">
            <div class="timeline-year">${item.year}</div>
            <div class="timeline-title">${currentLang === 'KR' ? (item.title_kr || item.title) : (item.title_en || item.title)}</div>
            <div class="timeline-desc">${currentLang === 'KR' ? item.desc_kr : item.desc_en}</div>
            <div class="timeline-tags">
                ${item.tags.map(tag => `<span class="tag">${tag}</span>`).join('')}
            </div>
        </div>
    `).join('');
}

function updateContent() {
    const c = content[currentLang];
    for (const key in c) {
        const el = document.getElementById(key);
        if (el) {
            if (key === 'bioText') {
                el.innerHTML = c[key];
            } else {
                el.textContent = c[key];
            }
        }
    }
    renderTimeline(journeyData, 'journeyTimeline');
    renderTimeline(workData, 'workTimeline');
    
    // Re-render MathJax after dynamic content is loaded
    if (typeof MathJax !== 'undefined' && MathJax.typeset) {
        MathJax.typeset();
    }
}

async function fetchUpdates() {
    const grid = document.getElementById('updatesGrid');
    try {
        const response = await fetch('https://dev.to/api/articles?username=luc1a_no&per_page=3');
        const posts = await response.json();
        
        if (posts.length === 0) {
            grid.innerHTML = '<div class="loading-spinner">No recent updates found.</div>';
            return;
        }

        grid.innerHTML = posts.map(post => `
            <a href="${post.url}" target="_blank" class="update-card">
                <div class="update-date">${new Date(post.published_at).toLocaleDateString()}</div>
                <div class="update-title">${post.title}</div>
                <div class="update-tags">
                    ${post.tag_list.map(tag => `<span class="tag">#${tag}</span>`).join('')}
                </div>
            </a>
        `).join('');
    } catch (error) {
        grid.innerHTML = '<div class="loading-spinner">Failed to load updates.</div>';
    }
}

function toggleLanguage() {
    currentLang = currentLang === 'KR' ? 'EN' : 'KR';
    document.getElementById('langBtn').textContent = currentLang === 'KR' ? 'EN' : 'KR';
    updateContent();
    if (typeof generateReCards === 'function') {
        generateReCards();
    }
}

function scrollToSection(sectionId) {
    document.getElementById(sectionId).scrollIntoView({ behavior: 'smooth' });
}

function getCurrentSection() {
    const scrollTop = window.scrollY;
    let currentSection = 'hero';
    sections.forEach(section => {
        const el = document.getElementById(section);
        if (el && el.offsetTop - 200 <= scrollTop) {
            currentSection = section;
        }
    });
    return currentSection;
}

// Progress bar & active nav dot
window.addEventListener('scroll', () => {
    const scrollTop = window.scrollY;
    const docHeight = document.documentElement.scrollHeight - window.innerHeight;
    const progress = (scrollTop / docHeight) * 100;
    document.getElementById('progressBar').style.width = progress + '%';

    let currentSection = 'hero';
    sections.forEach(section => {
        const el = document.getElementById(section);
        if (el && el.offsetTop - 200 <= scrollTop) {
            currentSection = section;
        }
    });

    document.querySelectorAll('.nav-dot').forEach(dot => {
        dot.classList.toggle('active', dot.dataset.section === currentSection);
    });
});

// Keyboard shortcuts
document.addEventListener('keydown', (e) => {
    const palette = document.getElementById('cmdPalette');
    const isPaletteOpen = palette.classList.contains('show');
    const isCmdK = isMac ? (e.metaKey && e.key === 'k') : (e.ctrlKey && e.key === 'k');

    if (isCmdK) {
        e.preventDefault();
        openCommandPalette();
        return;
    }

    if (e.key === 'Escape') {
        closeCommandPalette();
        return;
    }

    // Section Shortcuts (1-6)
    const sectionMap = {
        '1': 'hero', '2': 'journey', '3': 'work',
        '4': 'contact', '5': 're', '6': 'updates'
    };

    const key = e.key.toLowerCase();
    const isInput = e.target.tagName === 'INPUT' || e.target.tagName === 'TEXTAREA';

    if (sectionMap[key]) {
        if (!isInput || isPaletteOpen) {
            e.preventDefault();
            scrollToSection(sectionMap[key]);
            if (isPaletteOpen) closeCommandPalette();
        }
    }

    // Social & Functional Shortcuts
    const socialMap = {
        'g': 'https://github.com/XaicuL',
        'b': 'https://dev.to/luc1a_no',
        's': 'https://scholar.google.com/citations?user=-7L12NQAAAAJ&hl=en&authuser=1',
        'l': 'https://www.linkedin.com/in/luciano05/'
    };

    if (socialMap[key]) {
        if (!isInput || isPaletteOpen) {
            e.preventDefault();
            window.open(socialMap[key], '_blank');
            if (isPaletteOpen) closeCommandPalette();
        }
    }

    if (key === 't') {
        if (!isInput || isPaletteOpen) {
            e.preventDefault();
            toggleLanguage();
            if (isPaletteOpen) closeCommandPalette();
        }
    }

    if (!isPaletteOpen && !isInput) {
        if (key === 'j') {
            const currentIdx = sections.indexOf(getCurrentSection());
            if (currentIdx < sections.length - 1) {
                scrollToSection(sections[currentIdx + 1]);
            }
        }
        if (key === 'k') {
            const currentIdx = sections.indexOf(getCurrentSection());
            if (currentIdx > 0) {
                scrollToSection(sections[currentIdx - 1]);
            }
        }
    }
});

// Initialize on load
document.addEventListener('DOMContentLoaded', () => {
    updateContent();
    fetchUpdates();
    if (typeof generateReCards === 'function') {
        generateReCards();
    }
});
